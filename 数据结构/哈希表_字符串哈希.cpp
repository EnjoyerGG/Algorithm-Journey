// 字符串前缀哈希法，把字符串变成一个p进制数字，实现不同字符串映射到不同数字
// 映射公式：(X1*P^(n-1) + X2*P^(n-2) + ... + Xn*P^0) % Q
// 注意：任意字符不能映射为0，否则会出现不同字符串都映射成0的情况
// 冲突问题：通过巧妙设计P（131或13331）和Q（2^64）来降低冲突概率

/*给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2;
请你判断 [l1,r1] 和 [l2,r2]这两个区间所包含的字符串子串是否完全相同。
字符串中只包含大小写英文字母和数字。

输入样例：
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
输出样例：
Yes
No
Yes
*/

#include <iostream>
#include <algorithm>
using namespace std;
typedef unsigned long long ULL;
const int N = 100010, P = 131;

int n, m;
char str[N];
// h[i]前i个字符的哈希值
// 字符串变成一个p进制数字
ULL h[N], p[N];

ULL get(int l, int r) // 求[l,r]的哈希值
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", str + 1);

    p[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        h[i] = h[i - 1] * P + str[i]; // 前i个字符的哈希值
        p[i] = p[i - 1] * P;          // p的i次方
    }

    while (m--)
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

        // 两个区间的哈希值相同，说明两个区间的字符串相同
        if (get(l1, r1) == get(l2, r2))
        {
            puts("Yes");
        }
        else
        {
            puts("No");
        }
    }
    return 0;
}

/*
如何快速求出s[l, r]的哈希值h[s[l,r ]]是关键。这里可以使用前缀和思想。
字符串s的下标从1开始，字符串长度为n。P 取131。字符串s[1, t]对应的哈希值记为h[t]。
分别求出 h[1], h[2], h[3],h[n]
此时 h[s[l, r]] = h[r] - h[s[l - 1]] * pow(131, r - l + 1)
为什么？举个例子
例如s = "abcabcd", 各个位置对应的数字为： s = "97 98 99 97 98 99 100"

h[1] = 97
h[2] = h[1] * P + h['b'] = 97 * 131 + 98 = 12,805
h[3] = h[2] * P + h['c'] = 12805*131 + 99 = 1,677,554
h[4] = h[3] * P + h['a'] = 1,677,554 * 131 + 97 = 219,759,671
h[5] = h[4] * P + h['b'] = 219,759,671 * 131 + 98 =28,788,516,999
h[6] = h[5] * P + h['c'] = 28,788,516,999 * 131 + 99 = 3,771,295,726,968
h[7] = h[6] * P + h['d'] = 3,771,295,726,968 * 131 + 100 = 494,039,740,232,908

求 h[s[2, 3]]
h[3] = h['abc'] = h['a'] * pow(P, 2) + h['b'] * pow(P, 1) + h['c'] = 1,677,554
h[1] = h['a'] = 97
h[s[2, 3]] = h['bc'] = h['b'] * pow(P, 1) + h['c']
所以：h[s[2, 3]]= h[3] - h[1] * pow(P, 2) = 12,937
也就是：h[s[l, r]] = h[r] - h[l - 1] * pow(P, r - l + 1)
*/