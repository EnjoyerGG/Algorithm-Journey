//题目：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
//我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
//必须在不使用库内置的 sort 函数的情况下解决这个问题。

/*
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

输入：nums = [2,0,1]
输出：[0,1,2]

进阶：
你能想出一个仅使用常数空间的一趟扫描算法吗？
*/

//看到三种元素的分类问题，我首先会想到两端向中心的双指针。
//之前的快慢指针场景，是慢指针左侧维护一个索引区间，快指针在前面探路；
//可以在左右分别用指针 p0, p2 维护 0 的区间和 2 的区间，让第三个指针 p 遍历数组，把遇到的元素分类到左右两个区间中，最后中间剩下的也就是元素 1 了。

class Solution{
  public void sortColors(int[] nums){
    //注意区间的开闭，初始化时区间内没有元素
    //因此定义[0,p0)为元素0的区间， (p2, nums.length-1]是2的区间
    int p0 = 0;
    int p2 = nums.length-1;
    int p = 0;

    //p2是开区间，所以p<=p2
    while(p<=p2){
      if(nums[p]==0){
        swap(nums, p0, p);
        p0++;
      }
      else if(nums[p]==2){
        swap(nums, p2, p);
        p2--;
      }
      else if(nums[p]==1){
        p++;
      }

      //因为小于p0都是0，所以p不要小于p0
      if(p<p0){
        p=p0;
      }
    }
  }

  private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
}
      







      
